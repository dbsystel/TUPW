# TUPW

Safely store credentials in config files

## Command Line Program

This program serves as an example of how to safely store credentials in config files. It works as a command line tool to encrypt and decrypt credentials. The decryption part can be incorporated into an application.

The idea is to store credentials in a config file in an encrypted form like this:

    <credentials>
      <user name="dbuser" user="2$RigqmAZ27WkyzeM4b15N1g==$2Zofzxl47WC27qUO0CBiuw==$PhFw65T/tIAYp9Hem5ZvHd5dNfhgIaiXliHmP+U5JRg=" password="2$8yLidxWFry/YYi63PxiweQ==$RqMIUY2TKgViU7Pi9uZ//w==$pdRYin91BzlTdL6lXbtAGDgLLuZ9FsxrzL/rAXji7Nw="/>
    </credentialsÂ >

The encrypted data consists of four parts separated by '$' characters:

1. The format code:
  * 1 =`{IV}{AES-128-CFB-ABytPadding}{HMAC}`
  * 2 =`{IV}{AES-128-CTR-ABytPadding}{HMAC}`
2. The IV
3. The AES-128-CFB-ABytPadding encrypted data
3. The HMAC of the format code, the IV and the encrypted data

So these data specify the value of the initialization vector used for encryption, the type of encryption ([AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard "AES") 128 bit in [CFB](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#CFB "CFB") mode with [arbitrary tail byte ("ABytPadding") padding](https://eprint.iacr.org/2003/098.pdf "AByt-Pad"), and the [HMAC](https://en.wikipedia.org/wiki/Hash-based_message_authentication_code "HMAC") of all these values. But where does the encryption key come from?

The encryption key is generated by calculating the [HMAC](https://en.wikipedia.org/wiki/Hash-based_message_authentication_code "HMAC")-[SHA-256](https://en.wikipedia.org/wiki/SHA-2 "SHA-256") value of a file that is filled with random bytes. This file should be stored in a directory that is only accessible by the user that runs the application and nobody else.

The HMAC needs a key that is hard-coded in the program. So the key is calculated from something that is "known" (the HMAC key) and something that is in "posession" of the program (the file).

The above data can only be decrypted with the same file and the same HMAC key.

The program is used like this ('d:\keyfile.bin' is the name of the key file):

    java -jar tupw.jar encrypt d:\keyfile.bin dbUser

This generates (for example) the following output:

    2$RigqmAZ27WkyzeM4b15N1g==$2Zofzxl47WC27qUO0CBiuw==$PhFw65T/tIAYp9Hem5ZvHd5dNfhgIaiXliHmP+U5JRg=

Note that the "iv" part (the one after '1$') of the encryption will change with each invocation of the program as it is derived from a secure random number generator and hence the result of the encryption (which uses the random iv) and also the HMAC will be different, as well, even if the same key file is used in all of these invocations.

Of course, one would need the keyfile to decrypt this like so:

    java -jar tupw.jar decrypt d:\keyfile.bin "2$RigqmAZ27WkyzeM4b15N1g==$2Zofzxl47WC27qUO0CBiuw==$PhFw65T/tIAYp9Hem5ZvHd5dNfhgIaiXliHmP+U5JRg="

which yields (with the correct key file):

    dbUser
    
This way one can store the credentials and the key file in configuration management systems without storing them in the clear.

The decryption part of the program would typically be copied and used in an application to decrypt the credentials in the configuration file.

The program can also be used in a pipe to decode a file like this:

    java -jar tupw.jar decrypt d:\keyfile.bin - < cat encrypted-secret.config > plain.config
	
The trailing "-" tells the program that the input comes from stdin and not from the command line. This makes it possible to decrypt a secret configuration file, use it to start a server and then remove it after the sever has been started.

Of course, this is not perfectly safe, as an attacker can get access to the machine and extract the key file and the program classes and reverse engineer the way the key is calculated.

This program just makes it harder to get at the credentials, as both the file and the program code are needed to reconstruct the encryption key.

## Library

The command line program uses a library that can be found in the `dbscryptolib` source path. This library is the interface to the encryption and decryption methods. It is used like this:

    // This is the static HMAC key which is only known to the program
    // TODO: Do not use this constant byte array. Roll your own!!!!
    final byte[] HMAC_KEY = {(byte) 0xB4, (byte) 0xDC, (byte) 0x1C, (byte) 0x05,
       (byte) 0xCD, (byte) 0x1C, (byte) 0x30, (byte) 0xB8,
       (byte) 0x59, (byte) 0x80, (byte) 0x90, (byte) 0xC7,
       (byte) 0xFA, (byte) 0x4D, (byte) 0x07, (byte) 0x12,
       (byte) 0xD2, (byte) 0xA0, (byte) 0x67, (byte) 0xF5,
       (byte) 0x4C, (byte) 0x17, (byte) 0x11, (byte) 0xD0,
       (byte) 0x90, (byte) 0xF6, (byte) 0x53, (byte) 0x8A,
       (byte) 0x0B, (byte) 0xDF, (byte) 0xA4, (byte) 0x17};
    
	...
	
	try (FileAndKeyEncryption MyEncryptor = new FileAndKeyEncryption(HMAC_KEY, pathToKeyFile)) {
	   ...
       String decryptedData = MyEncryptor.decryptData(dataToDecrypt);
	   ...
	   // TODO: Do whatever you need to do with the decrypted string
    } catch (Exception e) {
       System.err.print(e.toString());
    }

I.e. the class `FileAndKeyEncryption` is instantiated with an HMAC key that is encoded in the program's source code and a key file whose path can be supplied as a parameter, or be read from a configuration file.

The class instance then generates a key from the HMAC of the key file and stores this key safely in the program's memory. When data have to be encrypted, or decrypted the calculated key is used for the requested cryptographic operation. Both operations expect a `String` as input data and return a `String` as output data. So you can not encrypt binary data with it, which makes kind of sense as it is designed to store readable data.
		 
## Contributing

Feel free to submit a pull request with new features, improvements on tests or documentation and bug fixes.

## Contact

Frank Schwab ([Mail](mailto:frank.schwab@deutschebahn.com "Mail"))

## License

TUPW is released under the 3-clause BSD license. See "LICENSE" for details.
